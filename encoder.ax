namespace ffmpeg

// ---------------------------------------------------------------------
// Encoder - wraps AVCodecContext for encoding
// ---------------------------------------------------------------------
struct Encoder {
    codec_ctx: *AVCodecContext
    codec: *AVCodec
    frame: *AVFrame
    packet: *AVPacket
    frame_count: int64
    width: int32
    height: int32
}

func create_h264_encoder(width: int32, height: int32, fps: int32, bitrate: int64) (Encoder, int32) {
    let enc = Encoder{
        codec_ctx: null,
        codec: null,
        frame: null,
        packet: null,
        frame_count: 0,
        width: width,
        height: height
    }
    
    // Find H.264 codec
    enc.codec = avcodec_find_encoder(AV_CODEC_ID_H264)
    if enc.codec == null {
        return (enc, -1)
    }
    
    // Allocate codec context
    enc.codec_ctx = avcodec_alloc_context3(enc.codec)
    if enc.codec_ctx == null {
        return (enc, -1)
    }
    
    // Set encoding parameters using accessors
    av_codec_set_bit_rate(enc.codec_ctx, bitrate)
    av_codec_set_width(enc.codec_ctx, width)
    av_codec_set_height(enc.codec_ctx, height)
    av_codec_set_time_base(enc.codec_ctx, AVRational{num: 1, den: fps})
    av_codec_set_framerate(enc.codec_ctx, AVRational{num: fps, den: 1})
    av_codec_set_gop_size(enc.codec_ctx, 10)
    av_codec_set_max_b_frames(enc.codec_ctx, 1)
    av_codec_set_pix_fmt(enc.codec_ctx, AV_PIX_FMT_YUV420P)
    
    // Open codec
    let opts: *AVDictionary = null
    av_dict_set(&opts, "preset", "medium", 0)
    av_dict_set(&opts, "crf", "23", 0)
    
    let rc = avcodec_open2(enc.codec_ctx, enc.codec, &opts)
    av_dict_free(&opts)
    
    if rc < 0 {
        avcodec_free_context(&enc.codec_ctx)
        return (enc, rc)
    }
    
    // Allocate frame and packet
    enc.frame = av_frame_alloc()
    enc.packet = av_packet_alloc()
    
    if enc.frame == null || enc.packet == null {
        enc.cleanup()
        return (enc, -1)
    }
    
    // Configure frame using accessors
    av_frame_set_format(enc.frame, AV_PIX_FMT_YUV420P)
    av_frame_set_width(enc.frame, width)
    av_frame_set_height(enc.frame, height)
    
    rc = av_frame_get_buffer(enc.frame, 0)
    if rc < 0 {
        enc.cleanup()
        return (enc, rc)
    }
    
    return (enc, 0)
}

func encode_frame(self e: *Encoder, on_packet: func(*AVPacket) void) int32 {
    // Make frame writable
    let rc = av_frame_make_writable(e.frame)
    if rc < 0 {
        return rc
    }
    
    av_frame_set_pts(e.frame, e.frame_count)
    e.frame_count = e.frame_count + 1
    
    // Send frame to encoder
    rc = avcodec_send_frame(e.codec_ctx, e.frame)
    if rc < 0 {
        return rc
    }
    
    // Receive encoded packets
    for true {
        rc = avcodec_receive_packet(e.codec_ctx, e.packet)
        if rc == AVERROR_EAGAIN || rc == AVERROR_EOF {
            break
        }
        if rc < 0 {
            return rc
        }
        
        on_packet(e.packet)
        av_packet_unref(e.packet)
    }
    
    return 0
}

func flush(self e: *Encoder, on_packet: func(*AVPacket) void) int32 {
    // Send null frame to flush encoder
    let rc = avcodec_send_frame(e.codec_ctx, null)
    if rc < 0 {
        return rc
    }
    
    // Receive remaining packets
    for true {
        rc = avcodec_receive_packet(e.codec_ctx, e.packet)
        if rc == AVERROR_EOF {
            break
        }
        if rc < 0 {
            return rc
        }
        
        on_packet(e.packet)
        av_packet_unref(e.packet)
    }
    
    return 0
}

func cleanup(self e: *Encoder) void {
    if e.frame != null {
        av_frame_free(&e.frame)
    }
    if e.packet != null {
        av_packet_free(&e.packet)
    }
    if e.codec_ctx != null {
        avcodec_free_context(&e.codec_ctx)
    }
}

// Helper to fill frame with test pattern
func fill_yuv_frame(self e: *Encoder, frame_index: int32) void {
    let y = av_frame_get_data(e.frame, 0)
    let u = av_frame_get_data(e.frame, 1)
    let v = av_frame_get_data(e.frame, 2)
    
    let y_linesize = av_frame_get_linesize(e.frame, 0)
    let u_linesize = av_frame_get_linesize(e.frame, 1)
    let v_linesize = av_frame_get_linesize(e.frame, 2)
    
    // Fill Y plane (luminance) with gradient
    let i: int32 = 0
    for i < e.height {
        let j: int32 = 0
        for j < e.width {
            let offset = i * y_linesize + j
            y[offset] = cast<byte>((i + j + frame_index) % 256)
            j = j + 1
        }
        i = i + 1
    }
    
    // Fill U and V planes (chrominance)
    i = 0
    for i < e.height / 2 {
        let j: int32 = 0
        for j < e.width / 2 {
            let offset = i * u_linesize + j
            u[offset] = cast<byte>(128 + i + frame_index)
            v[offset] = cast<byte>(64 + j + frame_index)
            j = j + 1
        }
        i = i + 1
    }
}